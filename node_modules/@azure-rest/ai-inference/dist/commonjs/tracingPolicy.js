"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.tracingPolicyName = void 0;
exports.tracingPolicy = tracingPolicy;
const core_tracing_1 = require("@azure/core-tracing");
const core_util_1 = require("@azure/core-util");
const constants_js_1 = require("./constants.js");
const logger_js_1 = require("./logger.js");
const tracingHelper_js_1 = require("./tracingHelper.js");
/**
 * The programmatic identifier of the tracingPolicy.
 */
exports.tracingPolicyName = "inferenceTracingPolicy";
/**
 * A simple policy to create OpenTelemetry Spans for each request made by the pipeline
 * that has SpanOptions with a parent.
 * Requests made without a parent Span will not be recorded.
 */
function tracingPolicy() {
    const tracingClient = (0, core_tracing_1.createTracingClient)({
        namespace: "Microsoft.CognitiveServices",
        packageName: "@azure/ai-inference-rest",
        packageVersion: constants_js_1.SDK_VERSION,
    });
    return {
        name: exports.tracingPolicyName,
        async sendRequest(request, next) {
            var _a, _b, _c, _d;
            const url = new URL(request.url);
            if (!tracingClient ||
                !url.href.endsWith("/chat/completions") ||
                ((_b = (_a = (0, tracingHelper_js_1.getRequestBody)(request)) === null || _a === void 0 ? void 0 : _a.body) === null || _b === void 0 ? void 0 : _b.stream)) {
                return next(request);
            }
            const { span, tracingContext } = (_c = tryCreateSpan(tracingClient, request)) !== null && _c !== void 0 ? _c : {};
            if (!span || !tracingContext) {
                return next(request);
            }
            try {
                (_d = request.tracingOptions) !== null && _d !== void 0 ? _d : (request.tracingOptions = {});
                request.tracingOptions.tracingContext = tracingContext;
                (0, tracingHelper_js_1.onStartTracing)(span, request, request.url);
                const response = await tracingClient.withContext(tracingContext, next, request);
                (0, tracingHelper_js_1.tryProcessResponse)(span, response);
                return response;
            }
            catch (err) {
                (0, tracingHelper_js_1.tryProcessError)(span, err);
                throw err;
            }
            finally {
                span.end();
            }
        },
    };
}
function tryCreateSpan(tracingClient, request) {
    try {
        // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.
        const { span, updatedOptions } = tracingClient.startSpan((0, tracingHelper_js_1.getSpanName)(request), { tracingOptions: request.tracingOptions }, {
            spanKind: "client",
        });
        return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
    }
    catch (e) {
        logger_js_1.logger.warning(`Skipping creating a tracing span due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
        return undefined;
    }
}
//# sourceMappingURL=tracingPolicy.js.map