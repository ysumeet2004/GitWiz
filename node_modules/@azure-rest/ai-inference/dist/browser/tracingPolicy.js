// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { createTracingClient, } from "@azure/core-tracing";
import { getErrorMessage } from "@azure/core-util";
import { SDK_VERSION } from "./constants.js";
import { logger } from "./logger.js";
import { getRequestBody, getSpanName, onStartTracing, tryProcessError, tryProcessResponse, } from "./tracingHelper.js";
/**
 * The programmatic identifier of the tracingPolicy.
 */
export const tracingPolicyName = "inferenceTracingPolicy";
/**
 * A simple policy to create OpenTelemetry Spans for each request made by the pipeline
 * that has SpanOptions with a parent.
 * Requests made without a parent Span will not be recorded.
 */
export function tracingPolicy() {
    const tracingClient = createTracingClient({
        namespace: "Microsoft.CognitiveServices",
        packageName: "@azure/ai-inference-rest",
        packageVersion: SDK_VERSION,
    });
    return {
        name: tracingPolicyName,
        async sendRequest(request, next) {
            var _a, _b, _c, _d;
            const url = new URL(request.url);
            if (!tracingClient ||
                !url.href.endsWith("/chat/completions") ||
                ((_b = (_a = getRequestBody(request)) === null || _a === void 0 ? void 0 : _a.body) === null || _b === void 0 ? void 0 : _b.stream)) {
                return next(request);
            }
            const { span, tracingContext } = (_c = tryCreateSpan(tracingClient, request)) !== null && _c !== void 0 ? _c : {};
            if (!span || !tracingContext) {
                return next(request);
            }
            try {
                (_d = request.tracingOptions) !== null && _d !== void 0 ? _d : (request.tracingOptions = {});
                request.tracingOptions.tracingContext = tracingContext;
                onStartTracing(span, request, request.url);
                const response = await tracingClient.withContext(tracingContext, next, request);
                tryProcessResponse(span, response);
                return response;
            }
            catch (err) {
                tryProcessError(span, err);
                throw err;
            }
            finally {
                span.end();
            }
        },
    };
}
function tryCreateSpan(tracingClient, request) {
    try {
        // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.
        const { span, updatedOptions } = tracingClient.startSpan(getSpanName(request), { tracingOptions: request.tracingOptions }, {
            spanKind: "client",
        });
        return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
    }
    catch (e) {
        logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);
        return undefined;
    }
}
//# sourceMappingURL=tracingPolicy.js.map